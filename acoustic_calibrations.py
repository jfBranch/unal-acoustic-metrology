import matplotlib.pyplot as plt
import pyvisa
import pyvisa as visa
import numpy as np
import pandas as pd
import cv2 as cv
import imutils
import os
import pickle
import logging
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.decomposition import KernelPCA
from sklearn.naive_bayes import GaussianNB
from skimage.metrics import structural_similarity as compare_ssim
from time import sleep, time
from PyQt5.QtCore import QObject, pyqtSignal, QMutex

__autor__ = 'Juan Felipe Maldonado'
__version__ = '1.0 Beta'
logging.basicConfig(
    format='%(asctime)s.%(msecs)03d   %(message)s',
    level=logging.INFO,
    datefmt='%H:%M:%S')
mutex = QMutex()


class AcousticCalibrator(object):
    """
    A class used to represent an acoustic calibrator or pistonphone.

    Programed by Felipe Maldonado,
    Universidad Nacional de Colombia, Faculty of Engineering, Department of Electrical and Electronic Engineering.
    Created on 2022/02/26.
    _____________
    Modifications:
        * [date] by [name]:
            +
            +
    -------------

    Attributes
    ----------
    _info: dict
        A dictionary with the basic information of the device: brand, model, serial number, identification and adaptor.
    _cl: int
        An integer value that specifies the class of the device according to IEC 60942:2017. May take values 1 or 2
    _nominal_values: pd.DataFrame
        A data frame with all nominal combinations of levels and frequencies that are available in the device.
    _pressure_influence: float
        A float value corresponding to the slope of a linear model of the influence of ambient pressure to the
        sound pressure level generated by the device. The units will be temporally just dB/kPa, i.e.
        A decrease of certain decibels for each 1 kPa decrement.
    _free_field_difference: float
        A float value corresponding to the difference between the level generated by the device coupled with a
        pressure field microphone and level generated coupled with a free field microphone.
    _calibration_results: pd.DataFrame
        A data frame that stores the measurement results (measurement values and expanded uncertainties) for
        all combinations of levels and frequencies that are available in the device.

    Methods
    -------
    get_ambient_correction(pressure: float)
        Returns the correction to the sound pressure level due to the influence of the atmospheric pressure.
    set_calibration_results(level_results: np.ndarray, freq_results: np.ndarray, thd_results: np.ndarray)
        Sets the measurement results (measurement values and expanded uncertainties) for
        all combinations of levels and frequencies that are available in the device.
    """

    __slots__ = ['_info', '_cl', '_nominal_values', '_pressure_influence',
                 '_free_field_difference', '_calibration_results']

    def __init__(self, brand: str, model: str, sn: str, identification: str, adaptor: str,
                 cl: int, nominal_values: np.ndarray, pressure_influence: float, free_field_difference: float = 0):
        """ Constructor method for instantiate an object of class AcousticCalibrator

        :param brand: Brand name of the acoustic calibrator or pistonphone
        :param model: Model of the acoustic calibrator or pistonphone
        :param sn: Serial number of the acoustic calibrator or pistonphone
        :param identification: Customer identification of the acoustic calibrator or pistonphone
        :param cl: IEC 60942:2017 class of the acoustic calibrator or pistonphone. May take value of 1 or 2.
        :param nominal_values: An array of floats with all nominal combinations of levels and frequencies that are
            available in the device. First level then frequency. Example: [[94, 1000], [114, 1000]].
        :param pressure_influence: Slope of a linear model of the influence of ambient pressure to the
            sound pressure level generated by the device.
        :param free_field_difference: The difference between the level generated by the device coupled with a
            pressure field microphone and level generated coupled with a free field microphone.
        """
        self._info = {'Brand': brand, 'Model': model, 'S/N': sn, 'ID': identification, 'Adaptor': adaptor}
        self._cl = cl
        self._nominal_values = pd.DataFrame(data=nominal_values, columns=['Level', 'Frequency'])
        self._pressure_influence = pressure_influence
        self._free_field_difference = free_field_difference
        self._calibration_results = None

    def get_ambient_correction(self, pressure: float) -> float:
        """This method returns the correction to the sound pressure level due to the influence
        of the atmospheric pressure.

        :param pressure: Atmospheric pressure value in kPa present during the measurements.
        :return: The correction value in dB to the sound pressure level.
        """
        if not 65 <= pressure <= 108:
            raise ValueError(
                'The atmospheric pressure must be between the specified range in IEC 60942: 65 kPa <= P <= 108 kPa.')
        # Computes the correction from the slope and pressure difference with respect to
        # the reference pressure (at sea level).
        return -self._pressure_influence * (pressure - 101.3)

    def set_calibration_results(self, level_results: np.ndarray, freq_results: np.ndarray,
                                thd_results: np.ndarray) -> None:
        """This method stores the measurement results (measurement values and expanded uncertainties) for
        all combinations of levels and frequencies that are available in the device.

        :param level_results: An array of float numbers with the measured SPL values on the first row and expanded
            uncertainties on the second for all the corresponding combinations of levels and frequencies.
        :param freq_results: An array of float numbers with the measured frequency values on the first row and expanded
            uncertainties on the second for all the corresponding combinations of levels and frequencies.
        :param thd_results: An array of float numbers with the measured THD+N values on the first row and expanded
            uncertainties on the second for all the corresponding combinations of levels and frequencies.
        :return: None
        """
        # Validates the shape of the results.
        if level_results.shape[1] == len(self._nominal_values) and freq_results.shape[1] == len(
                self._nominal_values) and thd_results.shape[1] == len(self._nominal_values):
            # Constructs a multi-index for the measurement value (y), error (E), and expanded uncertainty (U).
            iterables = [['SPL', 'Frequency', 'THD+N'], ['y', 'E', 'U']]
            index = pd.MultiIndex.from_product(iterables, names=['Quantity', 'Measurement result'])
            # Constructs the column names for the available nominal combinations SPL-frequency.
            columns = [str(self._nominal_values.iat[i, 0]) + ' dB @ ' + str(self._nominal_values.iat[i, 1]) + ' Hz' for
                       i in range(self._nominal_values.shape[0])]
            measurement_results = np.concatenate((level_results, freq_results, thd_results))  # Arms the data array
            self._calibration_results = pd.DataFrame(data=measurement_results, index=index, columns=columns)
        else:
            raise ValueError('You must assign as many calibration results as nominal combinations.')

    @property
    def info(self):
        return self._info

    @property
    def cl(self):
        return self._cl

    @property
    def nominal_values(self):
        return self._nominal_values

    @property
    def pressure_influence(self) -> float:
        return self._pressure_influence

    @property
    def free_field_difference(self) -> float:
        return float(self._free_field_difference)

    @property
    def calibration_results(self):
        if self._calibration_results is None:
            return "No calibration results available."
        return self._calibration_results


class AcousticCalibratorsPeriodicTester(QObject):
    """A class used to calibrate an acoustic calibrator according to the IEC 60942:2017 Annex B.
    The methods are designed to be executed in a parallel thread, emitting progress signals.

    Programed by Felipe Maldonado,
    Universidad Nacional de Colombia, Faculty of Engineering, Department of Electrical and Electronic Engineering.
    Created on 2022/03.
    _____________
    Modifications:
        * [date] by [name]:
            +
            +
    -------------

    Attributes
    ----------
    _resource_manager: pyvisa.ResourceManager
        This is the resource manager for current VISA session, with all the available controllable instruments.
    _DMM: pyvisa.GPIBInstrument
        This is a GPIBInstrument object that points to the digital multimeter and enables the controlling.
        This also contains the basic information and third part calibration results for traceability.
    _AA: pyvisa.GPIBInstrument
        This is a GPIBInstrument object that points to the audio analyzer and enables the controlling.
        This also contains the basic information and third part calibration results for traceability.
    _standard: AcousticCalibrator
        This is the AcousticCalibrator object that represents the acoustic calibrator standard used as reference
        for the calibration.
    _microphone: dict
        A dictionary containing the basic information of the reference microphone used in the calibration.
    _calibration_consecutive: str
        A string with the consecutive assigned to the current calibration and to the IBC.
    _dut: AcousticCalibrator
        This is the AcousticCalibrator object that represents the customer's acoustic calibrator
        that will be under test.
    _customer_info: dict
        A dictionary containing all the customer information required for the calibration certificate.
    _ambient_conditions_values: dict
        A dictionary containing DataFrames with the ambient conditions during the calibration on every level
        available on the customer's acoustic calibrator.
    _standard_measurement_values: list
        A list containing DataFrames with the results values of measured quantities on the
        standard acoustic calibrator on every level available.
    _standard_noise_values: pd.DataFrame
        A DataFrame with the results values of measured background noise using the
        standard acoustic calibrator on every level available.
    _dut_measurement_values: list
        A list containing DataFrames with the results values of measured quantities on the
        customer's acoustic calibrator on every level available.
    _dut_noise_values: pd.DataFrame
        A DataFrame with the results values of measured background noise using the
        customer's acoustic calibrator on every level available.
    _expanded_uncertainty: dict
        A dictionary containing DataFrames with the estimated expanded uncertainty on every level available.
    _current_level: int
        An integer defining the current level under calibration. For now, just takes values 0: 94 dB, 1: 114 dB.
    _calibration_stage: np.array
        A numpy array with the current stages of calibration on every level available on the customer's calibrator.
    _calibration_state: int
        The current state of the calibration process on the current level.
        This takes the values 0: stopped, 1: running, 2: paused.

    Methods
    -------
    run_main_sequence()
        Method that executes the corresponding process or actions to the current stage of the GRAFCET.
        This is the principal method launched in the parallel thread and that emits a signal of calibration progress.
    check_state()
        Method for entering an infinite loop when while the state of calibration changes to pause.
    set_current_level(level: int)
        Method for setting the current level under calibration.
    set_standard_calibrator(standard: AcousticCalibrator)
        Method for storing the standard acoustic calibrator object.
    set_dut(dut: AcousticCalibrator)
        Method for storing the customer's acoustic calibrator object.
    set_customer_info(customer_info: dict)
        Method for storing the customer's information.
    set_mic(mic: dict)
        Method for storing the reference microphone information.
    set_consecutive(consecutive: str)
        Method for storing the consecutive assigned to the current calibration and to the IBC.
    set_standards(DMM_info: dict, AA: dict)
        Method for storing the standards information and creating the respective GPIBInstruments objects.
    measure_mic_sensibility()
        Method for acquiring the preliminar measurement value of the microphone sensibility.
    """
    measurementProgress = pyqtSignal(int)  # Signal for updating the measurement progress in function of every stage
    calibrationProgress = pyqtSignal(int)  # Signal for updating the general calibration progress
    invalidMeasurementValue = pyqtSignal(float)  # Signal for indicate an invalid measurement value
    realTimeValues = pyqtSignal(tuple)  # Real time values reporting signal

    # Class attribute that stores the acceptance limits given in the IEC 60942:2017 for each class.
    __acceptanceLimits = pd.DataFrame(data=np.array([[0.25, 0.15], [0.4, 0.35],
                                                     [0.7, 0.2], [1.7, 0.2],
                                                     [2.5, 0.5], [3, 1]]),
                                      index=pd.MultiIndex.from_product([['SPL', 'Frequency', 'THD+N'], [1, 2]],
                                                                       names=['Quantity', 'Class']),
                                      columns=['A', 'Umax'])

    __slots__ = ['_calibration_consecutive', '_resource_manager', '_DMM', '_AA', '_standard', '_microphone', '_dut',
                 '_customer_info', '_ambient_condition_values', '_standard_measurement_values',
                 '_standard_noise_values', '_dut_measurement_values', '_dut_noise_values', '_expanded_uncertainty',
                 '_current_level', '_calibration_stage', '_calibration_state']

    def __init__(self) -> None:
        super().__init__()
        self._standard = []
        self._dut = []
        self._microphone = {}
        self._customer_info = {}
        self._calibration_consecutive = ''
        self._resource_manager = visa.ResourceManager()
        self._DMM = object()
        self._AA = object()
        self._standard_noise_values = pd.DataFrame()
        self._dut_noise_values = pd.DataFrame()
        iterables = [['0°', '120°', '240°'], ['V [V]', 'SPL [dB]', 'f [Hz]', 'THD+N [%]']]
        columns = pd.MultiIndex.from_product(iterables, names=['Orientation', 'Quantities'])
        self._standard_measurement_values = [pd.DataFrame(data=np.nan * np.ones((30, 12)), columns=columns),
                                             pd.DataFrame(data=np.nan * np.ones((30, 12)), columns=columns)]
        self._dut_measurement_values = [pd.DataFrame(data=np.nan * np.ones((30, 12)), columns=columns),
                                        pd.DataFrame(data=np.nan * np.ones((30, 12)), columns=columns)]
        self._current_level = 0
        self._calibration_stage = np.array([0, 0])
        self._calibration_state = 0

    def run_main_sequence(self) -> None:
        """
        This method executes the corresponding actions for each stage of the calibration, based on the designed GRAFCET.
        Also, emits the respective signal for communicating with the principal thread indicating a finishing.
        """
        if any([self._calibration_stage[self._current_level] == stage for stage in [0, 4, 7, 10, 13, 16, 19]]):
            # Stage transition, it's just virtual, really doesn't do anything
            self._calibration_stage[self._current_level] += 1
            self.calibrationProgress.emit(self._calibration_stage[self._current_level])
        elif self._calibration_stage[self._current_level] == 1:
            # Measurement of preliminar sensibility of the reference microphone
            self.measure_mic_sensibility()
            # Checks for an aceptable sensibility
            sensibility = self._microphone['Sensibility'][self._current_level] / 10 ** (
                    (self._dut.nominal_values.iloc[self._current_level, 0] - 94) // 20)
            if 380e-3 <= sensibility <= 460e-3:
                self._calibration_stage[self._current_level] += 1
                self.calibrationProgress.emit(self._calibration_stage[self._current_level])
            else:
                self.invalidMeasurementValue.emit(self._microphone['Sensibility'][self._current_level])
        elif any([self._calibration_stage[self._current_level] == stage for stage in [2, 5, 8, 11, 14, 17]]):
            # Measurement of background noise, both for standard or customer's acoustic calibrator.
            background_noise = self.measure_ambient_noise()
            if background_noise <= 65:
                self._calibration_stage[self._current_level] += 1
                self.calibrationProgress.emit(self._calibration_stage[self._current_level])
            else:
                self.invalidMeasurementValue.emit(background_noise)
        elif any([self._calibration_stage[self._current_level] == stage for stage in [3, 6, 9, 12, 15, 18]]):
            # Measurement of ICE 60942 required quantities: SPL, frequency and THD+N
            self.measure_quantities()
            self._calibration_stage[self._current_level] += 1
            self.calibrationProgress.emit(self._calibration_stage[self._current_level])

    def check_state(self):
        """
        Method for entering a loop while the calibration state is pause.
        """
        while True:
            mutex.lock()
            if self._calibration_state != 2:
                mutex.unlock()
                break
            mutex.unlock()
            sleep(0.3)  # Check for changes in the calibration state every 0.3 seconds.

    def set_current_level(self, level: int) -> None:
        """
        Method for setting the current level under calibration.
        :param level: An integer defining the current level under calibration.
                      For now, just takes values 0: 94 dB, 1: 114 dB.
        :return: None
        """
        if 0 <= level <= 1:
            self._current_level = level
        else:
            raise ValueError('Current level most be 0 for 94 dB or 1 for 114 dB')

    def set_standard_calibrator(self, standard: AcousticCalibrator) -> None:
        """
        Method for storing the standard acoustic calibrator object.
        :param standard: AcousticCalibrator object that represents the acoustic calibrator standard used as reference
                         for the calibration.
        :return: None
        """
        if self._calibration_state == 0 and self._calibration_stage.sum() == 0:
            self._standard = standard
            self._standard_noise_values = pd.DataFrame(data=np.nan * np.ones((len(self._standard.nominal_values), 3)),
                                                       columns=['0°', '120°', '240°'])
            pass
        else:
            raise RuntimeError('You can set the standard calibrator just at the beginning of the process.')

    def set_mic(self, mic: dict) -> None:
        """
        Method for storing the reference microphone information.
        :param mic: A dictionary containing the basic information of the reference microphone used in the calibration,
                    i.e. The keys of dictionary are Brand, Model, S/N, ID and Correction. Correction is the free-field
                    factor of the microphone at 1 kHz according to its calibration certificate.
        :return: None
        """
        if self._calibration_state == 0 and self._calibration_stage.sum() == 0:
            self._microphone = mic
            self._microphone['Sensibility'] = [0, 0]
        else:
            raise RuntimeError('You can set the microphone info just at the beginning of the process.')

    def set_dut(self, dut: AcousticCalibrator) -> None:
        """
        Method for storing the customer's acoustic calibrator object.
        :param dut: AcousticCalibrator object that represents the customer's acoustic calibrator
        that will be under test.
        :return: None
        """
        if self._calibration_state == 0 and self._calibration_stage.sum() == 0:
            self._dut = dut
            self._dut_noise_values = pd.DataFrame(data=np.nan * np.ones((len(self._dut.nominal_values), 3)),
                                                  columns=['0°', '120°', '240°'])
        else:
            raise RuntimeError('You can set the customer calibrator just at the beginning of the process.')

    def set_customer_info(self, customer_info: dict) -> None:
        """
        Method for storing the customer's information.
        :param customer_info: A dictionary containing all the customer information required for the calibration
                              certificate. The keys are Name, Address, City, Country, Postal code and Contact.
        :return: None
        """
        if self._calibration_state == 0 and self._calibration_stage.sum() == 0:
            self._customer_info = customer_info
        else:
            raise RuntimeError('You can set te customer info just at the beginning of the process.')

    def set_consecutive(self, consecutive: str) -> None:
        """
        Method for storing the consecutive assigned to the current calibration and to the DUT.
        :param consecutive: A string with the consecutive
        :return: None
        """
        # TODO: Programar determinación automática de consecutivos de calibración.
        self._calibration_consecutive = consecutive

    def set_standards(self, DMM: dict, AA: dict) -> None:
        """
        Method for storing the standards information and creating the respective GPIBInstruments objects.
        :param DMM: A dictionary with the information of the digital multimeter used for calibration. The keys are
                    Brand, Model, S/N, ID, GPIB bus and GPIB channel.
        :param AA: A dictionary with the information of the audio analyzer used for calibration. The keys are
                    Brand, Model, S/N, ID, GPIB bus and GPIB channel.
        :return: None
        """
        self._DMM = self._resource_manager.open_resource(
            'GPIB' + DMM['GPIB bus'] + '::' + DMM['GPIB channel'] + '::INSTR')
        self._DMM.info = DMM
        self._AA = self._resource_manager.open_resource(
            'GPIB' + AA['GPIB bus'] + '::' + AA['GPIB channel'] + '::INSTR')
        self._AA.info = AA

        # --- STANDARDS BASIC CONFIGURATIONS ---
        dmm_config = [':CONF:AC AUTO', ':CALC:AVER:STAT 1', ':CALC:AVER:CLE', ':SENS:VOLT:AC:BAND 20',
                      'SENS:VOLT:AC:SEC "FREQ"', ':TRIG:SOUR BUS']
        for config in dmm_config:
            self._DMM.write(config)
        aa_config = [':INIT:CONT:ANAL 0,(@1)', ':SENS:FILT:LPAS LP22,(@1)', ':SENS:FILT:HPAS HP22,(@1)',
                     ':SENS:FUNC1 THDR,(@1)', ':SENS:FUNC1:UNIT PCT,(@1)', ':SENS:ANAL:SAMP:SIZE 32768,(@1)',
                     ':CALC:STAT:STAT 1,(@1)', ':CALC:STAT:COUN 3,(@1)', ':CALC:STAT:TYPE1 AVG,(@1)',
                     ':CALC:STAT:RES (@1)', ':INP:ANAL:TYPE UNB,(@1)', ':INP:ANAL:COUP AC,(@1)',
                     ':INP:ANAL:IMP:UNB R100000,(@1)']
        for config in aa_config:
            self._AA.write(config)

    def measure_mic_sensibility(self) -> None:
        """
        Method for acquiring the preliminar measurement value of the microphone sensibility.
        """
        measurement_progress = 0
        stabilization_time = 10  # --> D
        wait_time = 5  # Waiting time while the multimeter will perform the measurement.
        dmm_config = [':TRIG:SOUR BUS', ':SAMP:COUN 20', ':TRIG:DEL 0.2', ':INIT', '*TRG', '*WAI', ':CALC:AVER:AVER?']
        total_steps = len(dmm_config) + (stabilization_time + wait_time) * 10  # Total steps for updating progress.
        for t in range(stabilization_time * 10):
            self.check_state()
            sleep(1 / 10)  # Updates progress every tenth of a second
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        for config in dmm_config:
            self.check_state()
            self._DMM.write(config)
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        for t in range(wait_time * 10):
            self.check_state()
            sleep(1 / 10)  # Updates progress every tenth of a second
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        # Stores the preliminar sensibility in the mic info
        self._microphone['Sensibility'][self._current_level] = float(self._DMM.read())
        self.measurementProgress.emit(0)  # Resets the progress bar

    def measure_ambient_noise(self) -> float:
        """
        Method for measuring the background noise with the acoustic calibrator
        shut down and coupled to the microphone.
        :return: Measurement value of the background noise.
        """
        measurement_progress = 0
        stabilization_time = 3  # --> D
        wait_time = 7  # Waiting time while the multimeter will perform the measurement.
        dmm_config = [':TRIG:SOUR BUS', ':SAMP:COUN 25', ':TRIG:DEL 0.2', ':INIT', '*TRG', '*WAI', ':CALC:AVER:AVER?']
        total_steps = len(dmm_config) + (stabilization_time + wait_time) * 10  # Total steps for updating progress.
        for t in range(stabilization_time * 10):
            self.check_state()
            sleep(1 / 10)  # Updates progress every tenth of a second
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        for config in dmm_config:
            self.check_state()
            self._DMM.write(config)
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        for t in range(wait_time * 10):
            self.check_state()
            sleep(1 / 10)  # Updates progress every tenth of a second
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))

        ref_lev = float(self._standard.calibration_results.loc['SPL'].loc['y'].iat[self._current_level])
        background_level = self.volt2level(float(self._DMM.read()),
                                           self._microphone['Sensibility'][self._current_level],
                                           ref_lev)  # Measured noise
        # If the current stage corresponds to the standard calibrator
        if self._calibration_stage[self._current_level] <= 9:
            self._standard_noise_values.iloc[self._current_level,
                                             (self._calibration_stage[self._current_level] - 2) // 3] = background_level
        else:  # If the current stage corresponds to the customer's calibrator
            self._dut_noise_values.iloc[self._current_level,
                                        (self._calibration_stage[self._current_level] - 11) // 3] = background_level
        self.measurementProgress.emit(0)  # Resets the progress bar
        return background_level

    def measure_quantities(self, n_indications: int = 30) -> None:
        """
        Method for measuring the required quantities by the ISO 60942: Sound pressure level, frequency,
        and harmonic distortion plus noise. Also, this method reports in "real-time" every acquired result.
        :param n_indications: An integer number of indications to acquire.
                              Default is 30, for a normal distribution approximation.
        :return: None
        """
        measurement_progress = 0
        stabilization_time = 18
        wait_time = 0.9
        dmm_config = [':TRIG:SOUR BUS', ':SAMP:COUN 1', ':TRIG:DEL:AUTO ON']
        [self._DMM.write(config) for config in dmm_config]
        self._AA.write(':INIT:CONT:ANAL 1,(@1)')
        total_steps = (stabilization_time + wait_time * n_indications) * 10  # Total steps for updating progress
        for t in range(stabilization_time * 10):
            self.check_state()
            sleep(1 / 10)  # Updates progress every tenth of a second
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        # TODO: Tomar en cuenta las condiciones ambientales reales durante la calibración
        ref_lev = float(self._standard.calibration_results.loc['SPL'].loc['y'].iat[self._current_level])
        ref_lev = ref_lev + self._standard.free_field_difference + self._standard.pressure_influence * (
                75 - 102.3) + self._microphone['Correction']
        dmm_config = [':INIT', '*TRG', '*WAI', ':FETC?']
        for indication in range(n_indications):  # Gets each indication
            self._AA.write(':CALC:STAT:RES (@1)')
            [self._DMM.write(config) for config in dmm_config]  # List comprehension to configure the multimeter
            for t in range(int(wait_time * 10)):
                self.check_state()
                sleep(1 / 10)  # Updates progress every tenth of a second
                measurement_progress += 1 / total_steps * 100
                self.measurementProgress.emit(int(measurement_progress))
            v = float(self._DMM.read())
            f = float(self._DMM.query(':DATA2?'))
            thd = float(self._AA.query(':CALC:STAT:DATA1? FUNC1,(@1)'))
            # If the current stage corresponds to the standard calibrator
            if self._calibration_stage[self._current_level] <= 9:
                df = self._standard_measurement_values[self._current_level]
                indexes = range((self._calibration_stage[self._current_level] // 3 - 1) * (1 + 3),
                                (self._calibration_stage[self._current_level] // 3 + 3) + 3 * (
                                        self._calibration_stage[self._current_level] // 3 - 1))
                df.iloc[indication, indexes] = [v, ref_lev, f, thd]
                self.realTimeValues.emit((v, ref_lev, f, thd))
                # Updates mic sensibility
                self._microphone['Sensibility'][self._current_level] = df.loc[:, (slice(None), "V [V]")].mean().mean()
            else:  # If the current stage corresponds to the customer's calibrator
                df = self._dut_measurement_values[self._current_level]
                # TODO: Tomar en cuenta las condiciones ambientales reales durante la calibración
                level = self.volt2level(v, self._microphone['Sensibility'][self._current_level], ref_lev)
                level = level - self._dut.free_field_difference - self._dut.pressure_influence * (
                        75 - 102.3) - self._microphone['Correction']
                indexes = range(((self._calibration_stage[self._current_level] - 9) // 3 - 1) * (1 + 3),
                                ((self._calibration_stage[self._current_level] - 9) // 3 + 3) + 3 * (
                                        (self._calibration_stage[self._current_level] - 9) // 3 - 1))
                df.iloc[indication, indexes] = [v, level, f, thd]
                self.realTimeValues.emit((v, level, f, thd))
            self._DMM.write('SYST:BEEP:IMM')
        self.measurementProgress.emit(0)  # Resets the progress bar

    def estimate_uncertainty(self) -> None:
        # TODO: Programar método para estimar la incertidumbre de medición.
        pass

    def report_ambient_conditions(self, temperature: float, humidity: float, pressure: float) -> None:
        # TODO: Programar secuencia para almacenar resultados de condiciones ambientales.
        pass

    def set_state(self, state: int) -> None:
        if 0 <= state <= 2:
            mutex.lock()
            self._calibration_state = state
            mutex.unlock()
        else:
            raise RuntimeError('You most assign only 0: stopped, 1: running, 2: paused.')

    def set_stage(self, stage: int) -> None:
        self._calibration_stage[self._current_level] = stage

    @staticmethod
    def volt2level(v: float, ref_v: float, ref_lev: float) -> float:
        from math import log10
        # ref_lev = float(self._standard.calibration_results.loc[('SPL', 'y')].iat[self._current_level])
        return ref_lev + 20 * log10(v / ref_v)

    # -- GET METHODS --
    @property
    def resource_manager(self):
        return self._resource_manager

    @property
    def DMM(self):
        return self._DMM

    @property
    def AA(self):
        return self._AA

    @property
    def microphone(self):
        return self._microphone

    @property
    def standard(self):
        return self._standard

    @property
    def dut(self):
        return self._dut

    @property
    def standard_noise_values(self):
        return self._standard_noise_values

    @property
    def dut_noise_values(self):
        return self._dut_noise_values

    @property
    def standard_measurement_values(self):
        return self._standard_measurement_values

    @property
    def dut_measurement_values(self):
        return self._dut_measurement_values

    @property
    def current_level(self):
        return self._current_level

    @property
    def stage(self):
        return self._calibration_stage[self._current_level]

    @property
    def state(self):
        return self._calibration_state


class SoundLevelMeter(object):
    """A class used to represent a sound level meter.

    Programed by Felipe Maldonado,
    Universidad Nacional de Colombia, Faculty of Engineering, Department of Electrical and Electronic Engineering.
    Created on 2022/04.
    _____________
    Modifications:
        * [date] by [name]:
            +
            +
    -------------

    Attributes
    ----------
    _info: dict
        A dictionary with the basic information of the device: brand, model, serial number and identification.
    _cl: int
        An integer value that specifies the class of the device according to IEC 61672-1:2013. May take values 1 or 2
    _preamplifier: dict
        A dictionary with the basic information of the preamplifier associated to the sound level meter: brand,
        model and serial number.dx
    _mic: dict
        A dictionary with the basic information of the microphone associated to the sound level meter: brand,
        model and serial number.
    _reference_level: float
        A float value that represents the reference level of the sound level meter specified in the instructions manual.
    _calibration_results: list
        A list of DataFrames with all the calibrations results. One DataFrame for each test of the IEC 61672-3:2013.

    Methods
    -------
        set_power_supply_values()
            Method for saving the power supply measured values on a DataFrame.
        set_calibration_check_indications()
            Method for saving the results of the indication at the calibration check frequency test.
        set_reference_voltage_values()
            Method for saving the obtained reference voltage values.
    """
    __slots__ = ['_info', '_cl', '_preamplifier', '_mic', '_power_supply_limits', '_reference_level',
                 '_frequency_ranges', '_lin_start_point', '_screen_rate', '_electrical_ff_corrections',
                 '_calibration_results']

    def __init__(self, slm_brand: str, slm_model: str, slm_sn: str, slm_identification: str, slm_cl: int,
                 power_supply_limits: tuple, reference_level: float, lu_1kHz: float, range_8kHz: tuple,
                 lin_start_point: float, screen_rate: float, electrical_ff_corrections: pd.DataFrame,
                 mic_brand: str, mic_model: str, mic_sn: str, pre_brand: str, pre_model: str, pre_sn: str):
        """
        Constructor method for instantiate an object of class SoundLevelMeter
        :param slm_brand: Brand name of the sound level meter
        :param slm_model: Model of the sound level meter
        :param slm_sn: Serial number of the sound level meter
        :param slm_identification: Customer identification of the sound level meter
        :param slm_cl: IEC 61672-1:2013  class of the sound level meter. May take value of 1 or 2
        :param power_supply_limits: Acceptance limits for the power supply of the sound level meter
        :param reference_level: Reference level of the sound level meter specified in the instructions manual
        :param lu_1kHz: Upper limit of the lineal level range at 1 kHz
        :param range_8kHz: Lineal level range at 8 kHz
        :param lin_start_point: Start point specified in the instructions manual for the linearity test
        :param screen_rate: Float value in milliseconds corresponding to the screen refresh rate of the level indicated
        :param electrical_ff_corrections: IEC62585 Free field corrections of the sound level meter with electric signals
        :param mic_brand: Brand of the microphone associated to the sound level meter
        :param mic_model: Model of the microphone associated to the sound level meter
        :param mic_sn: Serial number of the microphone associated to the sound level meter
        :param pre_brand: Brand of the preamplifier associated to the sound level meter
        :param pre_model: Model of the preamplifier associated to the sound level meter
        :param pre_sn: Serial number of the preamplifier associated to the sound level meter
        """
        self._info = {'Brand:': slm_brand, 'Model': slm_model, 'S/N': slm_sn, 'ID': slm_identification}
        self._cl = slm_cl
        self._power_supply_limits = power_supply_limits
        self._reference_level = reference_level
        self._frequency_ranges = {'1 kHz': (0, lu_1kHz), '8 kHz': range_8kHz}
        self._lin_start_point = lin_start_point
        self._screen_rate = 1 / (screen_rate / 1000)
        if electrical_ff_corrections.shape == (9, 6):
            self._electrical_ff_corrections = electrical_ff_corrections
        else:
            raise ValueError('You must assign valid free field corrections of shape (9, 6),' +
                             'including uncertainties.')
        self._mic = {'Brand': mic_brand, 'Model': mic_model, 'S/N': mic_sn}
        self._preamplifier = {'Brand': pre_brand, 'Model': pre_model, 'S/N': pre_sn}
        fw_df = pd.DataFrame(data=np.empty((27, 5), dtype=str),
                             index=pd.MultiIndex.from_product([[*'ACZ'],
                                                               np.array([63, 125, 250, 500, 1e3, 2e3, 4e3, 8e3, 16e3],
                                                                        dtype=int)]),
                             columns=['V', 'L', 'L_rel', 'R', 'LR_rel'])
        fw1kHz_df = pd.DataFrame(data=np.empty((3, 3), dtype=str),
                                 index=[*'ACZ'],
                                 columns=['V', 'L', 'L_rel'])
        tw1kHz_df = pd.DataFrame(data=np.empty((3, 3), dtype=str),
                                 index=['F', 'S', 'eq'],
                                 columns=['V', 'L', 'L_rel'])
        ind = np.arange(self._lin_start_point, self._frequency_ranges['8 kHz'][1], 5)
        ind = np.append(ind, np.arange(ind[-1] + 1, self._frequency_ranges['8 kHz'][1] + 1, 1))
        ind = np.append(ind, np.arange(self._lin_start_point, self._frequency_ranges['8 kHz'][0], -5))
        ind = np.append(ind, np.arange(ind[1] - 1, self._frequency_ranges['8 kHz'][0] - 1, -1))
        ref_linearity_df = pd.DataFrame(data=np.empty((ind.shape[0], 4), dtype=str),
                                        index=ind,
                                        columns=['V', 'G', 'L', 'L_rel'])
        self._calibration_results = {'Initial Adjustment': 0.0,
                                     'Calibration Check': pd.DataFrame(),
                                     'Power Supply': pd.DataFrame(),
                                     'Reference Voltage': pd.DataFrame(),
                                     'Electrical Frequency Weightings': fw_df,
                                     'Frequency Weightings 1 kHz': fw1kHz_df,
                                     'Time Weightings 1 kHz': tw1kHz_df,
                                     'Linearity Reference Range': ref_linearity_df}
        for weighting in [*'ACZ']:
            self._calibration_results['Electrical Frequency Weightings'].loc[weighting, 'LR_rel'] = np.zeros(9)
            R = self._electrical_ff_corrections[['Mic [dB]', 'Case [dB]', 'Screen [dB]']].sum(axis=1)
            self._calibration_results['Electrical Frequency Weightings'].loc[weighting, 'R'] = R.values
        self._calibration_results['Frequency Weightings 1 kHz'].loc[:] = np.zeros((3, 3))
        self._calibration_results['Time Weightings 1 kHz'].loc[:] = np.zeros((3, 3))

    def set_power_supply_values(self, values: np.ndarray) -> None:
        """
        This method takes the power supply values measured and saves them in the calibration results list.
        :param values: An array of 2 by 2 with the power supply values measured before and after of the electric and
                       acoustic tests.
        :return: None
        """
        if values.shape != (2, 2):  # Checks the shape of the array
            raise ValueError('The power supply values most be a 2x2 ndarray.')
        self._calibration_results['Power Supply'] = pd.DataFrame(data=values, columns=['Before', 'After'],
                                                                 index=['Acoustic Tests', 'Electric Tests'])

    def set_calibration_check_indications(self, init_adjustment: float, indications: np.array) -> None:
        """
        This method takes the values obtained in the indication at the calibration check frequency and saves them in
        the calibration results list.
        :param init_adjustment: A float that represents the value of the adjustment the sonometer had
                                at the beginning of the test.
        :param indications: An array with 3 rows corresponding to: 1) Levels obtained before the adjustment,
                            2) the adjustments, and 3) the levels obtained after the adjustment.
        :return: None
        """
        if indications.shape[0] != 3:  # Checks the shape of the indications array
            raise ValueError('The indications array must have 3 rows corresponding to the levels before adjustment,\n' +
                             'the adjustments and the levels after adjustment.')
        self._calibration_results['Initial Adjustment'] = init_adjustment
        self._calibration_results['Calibration Check'] = pd.DataFrame(indications,
                                                                      columns=range(1, indications.shape[1]),
                                                                      index=['Before Adjustment',
                                                                             'Adjustment', 'After Adjustment'])

    def set_reference_voltages_values(self, voltages: np.ndarray) -> None:
        """
        This method takes the reference voltage values, saves them in the calibration results list and calculates the
        corresponding reference voltage level and the voltage at the middle of the logarithmic interval of voltages that
        produce the reference level indication on the sonometer.
        :param voltages: A numpy array of two values: 1) Lower voltage and 2) upper voltage of the interval of voltages
                         that produce the reference level indication on the sonometer.
        :return: None
        """
        from math import log10, pow

        df = pd.DataFrame(data=np.zeros((1, 4), dtype=float),
                          columns=['Lower V', 'Upper V', 'Middle V Level', 'Middle V'])
        df.iloc[0, 0:2] = voltages
        Li = 20 * log10(voltages[0])
        Lu = 20 * log10(voltages[1])
        df.iloc[0, 2] = Li + (Lu - Li) / 2  # The voltage level at the middle of the logarithmic interval of voltages.
        df.iloc[0, 3] = pow(10, df.iloc[0, 2] / 20)  # The corresponding voltage to that level
        self._calibration_results['Reference Voltage'] = df

    def set_fweightings_result(self, weighting: str, result: float, frequency: int) -> None:
        """
        This method stores the given measurement value at the given frequency for the given
        weighting in the calibration results dataframe. Also, calculates and corrects the relative
        levels to the level at 1 kHz
        :param weighting: String character, either A, C or Z.
        :param result: The measurement value
        :param frequency: The frequency on which the measurement value was taken
        :return: None
        """
        self._calibration_results['Electrical Frequency Weightings'].loc[(weighting, frequency), 'L'] = result
        L_1k = self._calibration_results['Electrical Frequency Weightings'].loc[(weighting, 1000), 'L']
        if L_1k != '':
            L_rel = L_1k - self._calibration_results['Electrical Frequency Weightings'].loc[weighting, 'L']
            LR_rel = L_rel + self._calibration_results['Electrical Frequency Weightings'].loc[weighting, 'R']
            self._calibration_results['Electrical Frequency Weightings'].loc[weighting, 'L_rel'] = L_rel
            self._calibration_results['Electrical Frequency Weightings'].loc[weighting, 'LR_rel'] = LR_rel

    def set_ft_weightings_1kHz_result(self, is_freq: bool, result: float, substage: int) -> None:
        """
        This method stores the given measurement value at the given substage.
        The substage is related to the frequency or time weighting which the measurement value was taken.
        :param is_freq: True if the value is a result for the frequency weightings, false if it's for time weightings.
        :param result: The measurement value
        :param substage: The integer tag of the substage on which the measurement value was taken
        :return: None
        """
        if is_freq:
            self._calibration_results['Frequency Weightings 1 kHz'].loc[[*'ACZ'][substage], 'L'] = result
            LAF = self._calibration_results['Frequency Weightings 1 kHz'].loc['A', 'L']
            L_rel = LAF - self._calibration_results['Frequency Weightings 1 kHz']['L']
            self._calibration_results['Frequency Weightings 1 kHz']['L_rel'] = L_rel
        else:
            self._calibration_results['Time Weightings 1 kHz'].loc[['F', 'S', 'eq'][substage], 'L'] = result
            LAF = self._calibration_results['Time Weightings 1 kHz'].loc['F', 'L']
            L_rel = LAF - self._calibration_results['Time Weightings 1 kHz']['L']
            self._calibration_results['Time Weightings 1 kHz']['L_rel'] = L_rel

    def set_linearity_ref_range_result(self, result: float, substage: int) -> None:
        """
        This method stores the given measurement value at the given substage.
        The substage is related to the level on the linearity range on which the measurement value was taken.
        :param result: The measurement value
        :param substage: The integer tag of the substage on which the measurement value was taken
        :return:
        """
        levels = self._calibration_results['Linearity Reference Range'].index
        self._calibration_results['Linearity Reference Range'].loc[levels[substage], 'L'] = result
        L_ref = self._calibration_results['Linearity Reference Range'].loc[self._lin_start_point, 'L']
        L_rel = L_ref - self._calibration_results['Linearity Reference Range']['L']
        self._calibration_results['Linearity Reference Range']['L_rel'] = L_rel

    # Get methods
    @property
    def info(self):
        return self._info

    @property
    def cl(self):
        return self._cl

    @property
    def preamplifier(self):
        return self._preamplifier

    @property
    def mic(self):
        return self._mic

    @property
    def reference_level(self):
        return self._reference_level

    @property
    def lin_start_point(self):
        return self._lin_start_point

    @property
    def frequency_ranges(self):
        return self._frequency_ranges

    @property
    def calibration_results(self):
        return self._calibration_results

    @property
    def screen_rate(self):
        return self._screen_rate


class SLMPeriodicTester(QObject):
    """
    A class used to calibrate a sound level meter according to the IEC 61672-3:2013.
    The methods are designed to be executed in a parallel thread, emitting progress signals.

    Programed by Felipe Maldonado,
    Universidad Nacional de Colombia, Faculty of Engineering, Department of Electrical and Electronic Engineering.
    Created on 2022/04.
    _____________
    Modifications:
        * [date] by [name]:
            +
            +
    -------------

    Attributes
    ----------
    measurementProgress: pyqtSignal
        Signal for updating the measurement progress in function of every stage.
    calibrationProgress: pyqtSignal
        Signal for updating the measurement progress in function of every stage.
    realTimeValues: pyqtSignal
        Real time values reporting signal.
    timerStarted: pyqtSignal
        Signal for indicating the state of a timer related to the frames acquiring.
    loggingMsg: pyqtSignal
        Signal for transmitting a logging message.
    __ldaModel: LinearDiscriminantAnalysis
        Model for computing LDA for dimensionality reduction of the features vector.
    __kpcaModel: KernelPCA
        Model for computing KPCA for dimensionality reduction of the features vector.
    __gnbClassifier: GaussianNB
        Gaussian naive Bayes classifier
    __weightingFactors: pd.DataFrame
        Data frame with the nominal correction values established on the IEC 61672-1
        for the three frequency weightings: A, C and Z.
    _resource_manager: visa.ResourceManager
        This is the resource manager for current VISA session, with all the available controllable instruments.
    _AFG: pyvisa.GPIBInstrument
        This is a GPIBInstrument object that points to the arbitrary function generator and enables the controlling.
        This also contains the basic information and third part calibration results for traceability.
    _DMM: pyvisa.GPIBInstrument
        This is a GPIBInstrument object that points to the digital multimeter generator and enables the controlling.
        This also contains the basic information and third part calibration results for traceability.
    _calibration_consecutive: str
        A string representing the consecutive assigned to the sonometer and its accessories.
    _dut: SoundLevelMeter
        This is the SoundLevelMeter object that represents the customer's sonometer that will be under test.
    _customer_info: dict
        A dictionary containing all the customer information required for the calibration certificate.
    _ambient_conditions_values: list
        A list containing DataFrames with the results values of measured quantities on the
        standard acoustic calibrator on every level available.
    _camera: cv.VideoCapture
        This was the object used for the deprecated method detect_result().
    _result_box: tuple
        A tuple of the four coordinates (x1, y1, x2, y2) corresponding to the upper left and lower right corner of
        the rectangle around the level indicated on the sonometer screen.
    _calibration_stage: int
        The current stage of the calibration (see algorithm 4.1.)
    _calibration_state: int
        The current state of the calibration process on the current level.
        This takes the values 0: stopped, 1: running, 2: paused.
    _power_supply_results: np.array
        An array with the four measurement values for the stage 0 (power supply verification), according to IEC 61672-3.
    fweighting_results: dict
        A dictionary for storing the samples, transition matrices, and measurement values for the stages 5, 6, and 7
        (frequency weightings with electric signals) according to IEC 61672-3.
    freqtime_1kHz_results: dict
        A dictionary for storing the samples, transition matrices, and measurement values for the stages 8 and 9
        (frequency and time weightings at 1 kHz) according to IEC 61672-3.
    ref_linearity_results: dict
        A dictionary for storing the samples, transition matrices, and measurement values for the stage 10
        (linearity in the reference range of levels) according to IEC 61672-3.
    elect_stab_time: float
        The stabilization time of the sonometer for the tests with electrical signals.

    Methods
    -------
    train()
        This method read, process and extracts features vectors from a set of training images for the classifier.
        Then, this fits the Gaussian classifier.
    run_main_sequence()
        Method that executes the corresponding process or actions to the current step of the algorithm 4.1.
        This is the principal method launched in the parallel thread and that emits a signal of calibration progress.
    check_state()
        Method for entering a loop while the calibration state is paused. This method is called from other methods
        when is pertinent suspend the main sequence.
    set_dut()
        Method for storing the customer's SoundLevelMeter object.
    set_customer_info()
        Method for storing the customer's information.
    set_consecutive()
        Method for storing the consecutive assigned to the current calibration and to the DUT.
    set_standards()
        Method for storing the standards information and creating the respective GPIBInstruments objects.
    detect_result()
        Deprecated method used to detect automatically the result_box applying some electrical signals and detecting the
        changes on the screen.
    test_power_supply()
        This method checks the power supply of the sound level meter measuring DC voltage with the multimeter.
    test_electrical_fweightings()
        Method for performing the electrical frequency weightings tests with electrical signals, according to the
        IEC 61672-3:2013 Art. 13.
    set_state()
        Method for setting the current state of the calibration. Maybe 0: stopped, 1:running, 2: paused.
    read_screen()
        Method for processing and classifying a given image of the level displayed on the sonometer screen.
    level2volt()
        This method returns the voltage value corresponding to the required level in function
        of the voltage that produces an indication of the reference level.
    """
    measurementProgress = pyqtSignal(int)  # Signal for updating the measurement progress in function of every stage
    calibrationProgress = pyqtSignal(int)  # Signal for updating the general calibration progress
    realTimeValues = pyqtSignal(tuple)  # Real time values reporting signal
    gainChanged = pyqtSignal(int)  # Sinal for indicating a manual change required on the attenuation of DecadeBox
    timerStarted = pyqtSignal(bool)  # Signal for indicating the state of a timer related to the frames acquiring
    loggingMsg = pyqtSignal(tuple)  # Signal for transmitting a logging message.

    __ldaModel = LinearDiscriminantAnalysis(n_components=10)  # «class attribute» LDA for dimensionality reduction
    __kpcaModel = KernelPCA(n_components=16)  # «class attribute» KPCA for dimensionality reduction
    __gnbClassifier = GaussianNB()  # «class attribute» Gaussian naive Bayes classifier
    # «class attribute» All the weighting factors for A, C and Z networks according to the IEC 61672-3:2013
    __weightingFactors = pd.DataFrame(data=np.array([[26.2, 0.8, 0], [16.1, 0.2, 0], [8.6, 0, 0], [3.2, 0, 0],
                                                     [0, 0, 0], [-1.2, 0.2, 0], [-1, 0.8, 0], [1.1, 3, 0],
                                                     [6.6, 8.5, 0]]),
                                      index=np.array([63, 125, 250, 500, 1e3, 2e3, 4e3, 8e3, 16e3], dtype=float),
                                      columns=['A', 'C', 'Z'])

    __slots__ = ['_resource_manager', '_AFG', '_DMM', '_calibration_consecutive', '_dut', '_customer_info',
                 '_ambient_conditions_values', '_camera', '_result_box', '_calibration_stage', '_calibration_substage',
                 '_calibration_state', '_power_supply_results', 'fweighting_results', 'f_weightings_1kHz',
                 't_weightings_1kHz', 'linearity_ref_range', 'elect_stab_time']

    def __init__(self):
        super().__init__()
        self._resource_manager = visa.ResourceManager()  # Open resource manager for VISA Instruments
        self._AFG = object()
        self._DMM = object()
        self._calibration_consecutive = ''
        self._dut = object()
        self._customer_info = {}
        # self._camera = cv.VideoCapture(0, cv.CAP_MSMF)
        self._result_box = (0, 0, 0, 0)
        self._calibration_stage = self._calibration_substage = self._calibration_state = 0
        self._power_supply_results = np.empty((2, 2), dtype=float)
        self.fweighting_results = {'Samples': {}, 'Transition Matrix': {},
                                   'Stationary Distribution': {}, 'Expected Value': {}}
        self.f_weightings_1kHz = {'Samples': {}, 'Transition Matrix': {},
                                  'Stationary Distribution': {}, 'Expected Value': {}}
        self.t_weightings_1kHz = {'Samples': {}, 'Transition Matrix': {},
                                  'Stationary Distribution': {}, 'Expected Value': {}}
        self.linearity_ref_range = {'Samples': {}, 'Transition Matrix': {},
                                    'Stationary Distribution': {}, 'Expected Value': {}}
        self.current_frequency = 0  # The current frequency of electrical frequency weightings test
        self.elect_stab_time = 2  # Seconds for stabilisation in electrical tests
        self.wrong_frames = []

    def train(self, path: str = 'Images/Train'):
        """
        This class method reads a set of training images of screen digits, segments them
        by binary Otsu threshold, extracts the features vectors based in SIFT descriptor,
        reduces de dimensionality, and fits a Gaussian naive Bayes classifier.
        :param path: Path to the training set of images
        :return: None
        """
        descriptor = cv.SIFT_create()  # Crea un descriptor SIFT
        X = []  # Features arrays of training samples
        y = []  # Classes of training samples
        measurement_progress = 0
        total_steps = len(os.listdir(path)) + 2
        for img_name in os.listdir(path):  # Read every frames in training set
            if ".ini" in img_name:
                continue
            img = cv.imread(path + "/" + img_name, cv.IMREAD_GRAYSCALE)  # Read frames
            roi = cv.GaussianBlur(img.copy(), ksize=(0, 0), sigmaX=1.5)  # Gaussian filter
            mayor_axis = max(roi.shape)  # The largest axis
            digit_scaled = cv.resize(roi, (0, 0), fx=32 / mayor_axis,  # Normalize size
                                     fy=32 / mayor_axis, interpolation=cv.INTER_CUBIC)
            # Build an frames of 32 x 32 pixels
            if digit_scaled.shape[0] >= digit_scaled.shape[1]:
                digit_scaled = np.pad(digit_scaled, ((0, 0), ((32 - digit_scaled.shape[1]) // 2,
                                                              (32 - digit_scaled.shape[1]) // 2)), 'constant')
            else:
                digit_scaled = np.pad(digit_scaled, (((32 - digit_scaled.shape[0]) // 2,
                                                      (32 - digit_scaled.shape[0]) // 2), (0, 0)), 'constant')
            img_bin = cv.threshold(digit_scaled, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)[1]  # Otsu binarization
            # Four key points for computing SIFT descriptor
            key_points = [cv.KeyPoint(7, 7, 16), cv.KeyPoint(7, 13, 16),
                          cv.KeyPoint(13, 7, 16), cv.KeyPoint(13, 13, 16)]
            _, des = descriptor.compute(img_bin, key_points)  # Computes SIFT descriptor
            X.append(des.flatten())  # Add the features vector of the actual sample
            y.append(img_name[0])  # Add the class of the actual sample
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))

        X = np.array(X)  # Convert features vector to numpy array
        y = np.array(y)  # Convert samples labels to numpy array

        # -------- DIMENSIONALITY REDUCTION BY KERNEL PCA --------- #
        # Fits the model and apply transformation to the features vector
        X = SLMPeriodicTester.__kpcaModel.fit_transform(X, y)
        measurement_progress += 1 / total_steps * 100
        self.measurementProgress.emit(int(measurement_progress))
        # ---------- FITS THE CLASSIFIER ----------#
        SLMPeriodicTester.__gnbClassifier.fit(X, y)
        measurement_progress += 1 / total_steps * 100
        self.measurementProgress.emit(int(measurement_progress))
        self.measurementProgress.emit(0)

    def run_main_sequence(self):
        """
        This method executes the corresponding actions for each step of the calibration,
        based on the designed algorithm. Also, emits the respective signal for communicating
        with the principal thread indicating a finishing.
        """
        from math import log10
        if any([self._calibration_stage == stage for stage in [0, 2, 4]]):
            # Stage transition, it's just virtual, really doesn't do anything.
            # This is called on the start stage, indication at the calibration check frequency and reference voltage.
            if self._calibration_stage == 0:  # Except in stage 0, when the classifier is trained
                self.train()
                self.loggingMsg.emit((0, 'Finaliza entrenamiento del clasificador bayesiano.'))
            self._calibration_stage += 1
            self.calibrationProgress.emit(self._calibration_stage)
        elif any([self._calibration_stage == stage for stage in [1, 3, 11]]):
            # Power supply checks
            self.loggingMsg.emit((1, "Inicia verificación de la fuente de alimentación."))
            self.test_power_supply()
            self.loggingMsg.emit((0, "Termina verificación de la fuente de alimentación."))
            self._calibration_stage += 1
            self.calibrationProgress.emit(self._calibration_stage)
        elif any([self._calibration_stage == stage for stage in range(5, 8)]):
            # Electrical signal tests of frequency weightings
            W = [*'ACZ']
            msg = f"Inicia la prueba de ponderación frecuencial {W[self._calibration_stage - 5]}"
            self.loggingMsg.emit((1, msg + " con señales eléctricas."))
            self._calibration_substage = 0
            self.test_electrical_fweightings(W[self._calibration_stage - 5])
            msg = f"Finaliza la prueba de ponderación frecuencial {W[self._calibration_stage - 5]}"
            self.loggingMsg.emit((0, msg + " con señales eléctricas."))
            self._calibration_substage = 0
            self._calibration_stage += 1
            self.calibrationProgress.emit(self._calibration_stage)
        elif self._calibration_stage == 8:
            # Frequency and time weightings at 1 kHz
            W = [*'ACZ']
            T = ['S', 'eq']
            if self._calibration_substage == 0:
                self.loggingMsg.emit((1, 'Inicia la prueba de ponderaciones frecuenciales y temporales a 1 kHz.'))
            if self._calibration_substage <= 2:  # Frequency weighting label
                level = f'L{W[self._calibration_substage]}F'
                self.loggingMsg.emit((0, f'Inicia el reconocimiento del nivel {level}.'))
            elif self._calibration_substage == 3:  # Time weighting label
                level = f'LA{T[self._calibration_substage - 3]}'
                self.loggingMsg.emit((0, f'Inicia el reconocimiento del nivel {level}.'))
            else:  # LAeq label
                level = f'LA{T[self._calibration_substage - 3]}'
                self.loggingMsg.emit((0, f'Inicia la medición del nivel {level}.'))
            self.test_freqtime_weightings_1kHz()
            self._calibration_substage += 1
            if self._calibration_substage >= 5:
                self._calibration_substage = 0
                self._calibration_stage += 1
                self.loggingMsg.emit((1, 'Finaliza la prueba de ponderaciones frecuenciales y temporales a 1 kHz.'))
                # self._dut.set_ft_weightings_1kHz_results(self.f_weightings_1kHz, self.t_weightings_1kHz)
            self.calibrationProgress.emit(self._calibration_stage)
        elif self._calibration_stage == 9:
            # Level linearity on the reference level range
            self.loggingMsg.emit((1, 'Inicia la prueba de linealidad en el rango de niveles de referencia.'))
            self._calibration_substage = 0
            self.test_linearity_ref_range()
            self._calibration_substage = 0
            self._calibration_stage += 1
            self.calibrationProgress.emit(self._calibration_stage)

    def check_state(self):
        """
        Method for entering a loop while the calibration state is pause.
        """
        while True:
            mutex.lock()
            if self._calibration_state != 2:
                mutex.unlock()
                break
            mutex.unlock()
            sleep(0.3)  # Check for changes in the calibration state every 0.3 seconds.

    def set_dut(self, dut: SoundLevelMeter):
        """
        Method for storing the customer's sound level meter object.
        :param dut: SoundLevelMeter object that represents the customer's sound level meter
        that will be under test.
        :return: None
        """
        if self._calibration_state == 0 and self._calibration_stage == 0:
            self._dut = dut
        else:
            raise RuntimeError('You can set the customer sonometer just at the beginning of the process.')

    def set_customer_info(self, customer_info: dict):
        """
        Method for storing the customer's information.
        :param customer_info: A dictionary containing all the customer information required for the calibration
                              certificate. The keys are Name, Address, City, Country, Postal code and Contact.
        :return: None
        """
        if self._calibration_state == 0 and self._calibration_stage == 0:
            self._customer_info = customer_info
        else:
            raise RuntimeError('You can set te customer info just at the beginning of the process.')

    def set_consecutive(self, consecutive: str):
        """
        Method for storing the consecutive assigned to the current calibration and to the DUT.
        :param consecutive: A string with the consecutive
        :return: None
        """
        # TODO: Programar determinación automática de consecutivos de calibración.
        self._calibration_consecutive = consecutive

    def set_standards(self, AFG: dict, DMM: dict) -> None:
        """
        Method for storing the standards information and creating the respective GPIBInstruments objects.
        :param AFG: A dictionary with the information of the arbitrary function generator used for calibration. The keys
                    are Brand, Model, S/N, ID, GPIB bus and GPIB channel.
        :param DMM: A dictionary with the information of the digital multimeter used for calibration. The keys
                    are Brand, Model, S/N, ID, GPIB bus and GPIB channel.
        :return: None
        """
        from math import log10
        self._AFG = self._resource_manager.open_resource(
            'GPIB' + AFG['GPIB bus'] + '::' + AFG['GPIB channel'] + '::INSTR')
        self.loggingMsg.emit((0, "Generador de señales conectado."))
        self._AFG.info = AFG
        self._AFG.info['Limits'] = pd.DataFrame(data=np.array([[10 ** ((20 * log10(2e-3) - 50) / 20),
                                                                2e-3, 7, 10 ** ((20 * log10(7) + 6) / 20)],
                                                               [400e-3, 400e-3, 800e-3, 800e-3]]),
                                                index=['Out 1', 'Out 2'],
                                                columns=['With attenuation', 'Without attenuation',
                                                         'Without gain', 'With gain'])
        self._AFG.gain = 0
        self._DMM = self._resource_manager.open_resource(
            'GPIB' + DMM['GPIB bus'] + '::' + DMM['GPIB channel'] + '::INSTR')
        self.loggingMsg.emit((0, "Multímetro conectado."))
        self._DMM.info = DMM

        # --- STANDARDS BASIC CONFIGURATIONS ---
        afg_config = [':VOLT:UNIT VRMS', ':OUTP:LOAD INF', 'OUTP OFF']
        for config in afg_config:
            self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: '{config}'."))
            self._AFG.write(config)
        dmm_config = [':CONFigure:VOLTage:DC 100', ':SENSe:VOLTage:DC:NPLCycles 10', ':SAMPle:COUNt 30',
                      ':DISPlay:VIEW NUMeric', ':CALCulate:AVERage:STATe 1', ':CALCulate:CLEar:IMMediate',
                      ':TRIGger:SOURce BUS', ':TRIGger:DELay:AUTO 1']
        for config in dmm_config:
            self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: '{config}'."))
            self._DMM.write(config)

    # def detect_result(self):
    #     """
    #     This method sends some electrical signals to detect automatically the
    #     changes in the screen of the sound level meter.
    #     :return:
    #     """
    #     test_levels = np.array([63.3, 134.2, 70.2, 124.9])
    #     resolution = (int(self._camera.get(cv.CAP_PROP_FRAME_WIDTH)), int(self._camera.get(cv.CAP_PROP_FRAME_HEIGHT)))
    #     screen0 = np.zeros(resolution)
    #     sizes = []
    #     for test_level, i in zip(test_levels, range(test_levels.shape[0])):
    #         self._AFG.write(f':APPL:SIN 1000,{self.level2volt(test_level, self._ref_lev)}')  # Send signal
    #         sleep(3.5)  # Stabilization time
    #         if i == 0:
    #             screen0 = self._camera.read()[1]
    #             screen0 = cv.GaussianBlur(cv.cvtColor(screen0, cv.COLOR_BGR2GRAY), ksize=(0, 0), sigmaX=3)
    #         else:
    #             screen1 = self._camera.read()[1]
    #             screen1 = cv.GaussianBlur(cv.cvtColor(screen1, cv.COLOR_BGR2GRAY), ksize=(0, 0), sigmaX=3)
    #             (score, diff) = compare_ssim(screen0, screen1, full=True)  # Detect differences
    #             diff = (diff * 255).astype("uint8")
    #             thresh = cv.threshold(diff, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU)[1]
    #             plt.imshow(thresh, cmap='gray')
    #             plt.show()
    #             thresh = cv.morphologyEx(thresh, cv.MORPH_CLOSE,  # Closing morphology operation
    #                                      cv.getStructuringElement(cv.MORPH_CROSS, (7, 7)), iterations=5)
    #             thresh = cv.dilate(thresh, cv.getStructuringElement(cv.MORPH_CROSS, (7, 7)), iterations=3)  # Dilation
    #             plt.imshow(thresh, cmap='gray')
    #             plt.show()
    #             # Find de possibles bounding rectangles of the result
    #             cnts = cv.findContours(thresh.copy(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    #             cnts = imutils.grab_contours(cnts)
    #             for c in cnts:
    #                 (x, y, w, h) = cv.boundingRect(c)
    #                 sizes.append([x, y, w, h])
    #             screen0 = screen1
    #
    #     sizes = np.array(sizes)
    #     areas = np.multiply(sizes[:, 2], sizes[:, 3])
    #     max_area_idx = np.argmax(areas)  # The rectangle with maximum area
    #     self._AFG.write('OUTP OFF')
    #     self._result_box = tuple(np.add(sizes[max_area_idx], np.array([-5, -5, 5, 5])))

    def test_power_supply(self):
        """
        This method checks the power supply of the sound level meter measuring DC voltage with the multimeter.
        :return: None
        """
        measurement_progress = 0
        wait_time = 11  # Waiting time while the multimeter will perform the measurement.
        dmm_config = [':INITiate:IMMediate', '*TRG']
        total_steps = len(dmm_config) + wait_time * 10  # Total steps for updating progress.
        for config in dmm_config:
            self.check_state()
            self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: '{config}'."))
            self._DMM.write(config)
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        for t in range(wait_time * 10):
            self.check_state()
            sleep(1 / 10)  # Updates progress every tenth of a second
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
        cmd = ':CALCulate:AVERage:AVERage?'
        self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: '{cmd}'."))
        power_supply_voltage = self._DMM.query(cmd)
        if self._calibration_stage == 1:
            self._power_supply_results[0, 0] = power_supply_voltage
        elif self._calibration_stage == 3:
            self._power_supply_results[0, 1] = power_supply_voltage
            self._power_supply_results[1, 0] = power_supply_voltage
        elif self._calibration_stage == 11:
            self._power_supply_results[1, 1] = power_supply_voltage
        self._dut.set_power_supply_values(self._power_supply_results)
        self.measurementProgress.emit(0)

    def test_electrical_fweightings(self, weighting: str) -> None:
        """
        Method for performing the frequency weightings tests with electrical signals, according to the
        IEC 61672-3:2013 Art. 13. The weightings checked can be A, C and Z, at the nominal middle frequencies of octave
        bands.
        For that purpose, this method starts a timer, sets sine signals of certain amplitude depending on the frequency
        and weighting, and, after about 25 seconds, finishes the timer. While timer is running, the video frames are
        acquired and stored.
        :param weighting: Frequency weighting that will be tested.
        :return: None
        """
        measurement_progress = 0
        measuring_time = 25  # Time for capturing video frames (including stabilization time)
        total_steps = measuring_time * 10 * self.__weightingFactors.shape[0]
        test_level = self._dut.frequency_ranges['1 kHz'][1] - 45  # Test level according to the IEC 61672-3:2013
        for f, w in zip(self.__weightingFactors.index, self.__weightingFactors[weighting]):
            v = self.level2volt(test_level + w,
                                (self._dut.reference_level,
                                 self._dut.calibration_results['Reference Voltage'].iat[0, 3]))  # Voltage test
            self._dut.calibration_results['Electrical Frequency Weightings'].iat[9 * (self._calibration_stage - 5) +
                                                                                 self._calibration_substage, 0] = v
            # Starts timer for video capturing
            self.timerStarted.emit(True)
            total_time = 0
            # prev_time = time()
            afg_flag = False
            for t in range(1, measuring_time * 10 + 1):
                self.check_state()
                sleep(1 / 10)
                total_time += t / 10
                measurement_progress += 1 / total_steps * 100
                self.measurementProgress.emit(int(measurement_progress))
                if not afg_flag and total_time >= 0.3:
                    self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: ':APPL:SIN {f},{v}'."))
                    self._AFG.write(f':APPL:SIN {f},{v}')  # Send test signal of frequency and voltage required
                    afg_flag = True

            # while total_time <= measuring_time + 0.1:
            #     time_elapsed = time() - prev_time
            #     if time_elapsed > 1 / 10:
            #         self.check_state()
            #         prev_time = time()
            #         total_time += time_elapsed
            #         measurement_progress += 1 / total_steps * 100
            #         # logging.info(f'Time elapsed: {total_time} s')
            #         self.measurementProgress.emit(int(measurement_progress))
            #     if not afg_flag and total_time >= 0.2:
            #         logging.info(f':APPL:SIN {f},{v}')
            #         self._AFG.write(f':APPL:SIN {f},{v}')  # Send test signal of frequency and voltage required
            #         afg_flag = True
            self.timerStarted.emit(False)
            self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: 'OUTP 0'."))
            self._AFG.write('OUTP 0')
            self._calibration_substage += 1
            sleep(1)
        self.measurementProgress.emit(0)

    def test_freqtime_weightings_1kHz(self) -> None:
        """
        Method for performing the electrical frequency  and time weightings tests at 1 kHz with electrical signals,
        according to the IEC 61672-3:2013 Art. 13.
        For that purpose, this method starts a timer, sets sine signals of with an amplitude that produce the reference
        level at 1 kHz, and, after about 15 seconds, finishes the timer. While timer is running, the video frames are
        acquired and stored.
        :return: None
        """
        measurement_progress = 0
        measuring_time = 15  # Time for capturing video frames (including stabilization time)
        total_steps = measuring_time * 10
        W = [*'ACZ']
        T = ['S', 'eq']
        v = self.level2volt(self._dut.reference_level,
                            (self._dut.reference_level,
                             self._dut.calibration_results['Reference Voltage'].iat[0, 3]))  # Voltage test
        if self._calibration_substage <= 2:
            self._dut.calibration_results['Frequency Weightings 1 kHz'].loc[W[self._calibration_substage], 'V'] = v
            if self._calibration_substage == 0:
                self._dut.calibration_results['Time Weightings 1 kHz'].loc['F', 'V'] = v
        else:
            self._dut.calibration_results['Time Weightings 1 kHz'].loc[T[self._calibration_substage - 3], 'V'] = v
        self.timerStarted.emit(True)
        total_time = 0
        afg_flag = False
        for t in range(1, measuring_time * 10 + 1):
            self.check_state()
            sleep(1 / 10)
            total_time += t / 10
            measurement_progress += 1 / total_steps * 100
            self.measurementProgress.emit(int(measurement_progress))
            if not afg_flag and total_time >= 0.3:
                self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: ':APPL:SIN 1000,{v}'."))
                self._AFG.write(f':APPL:SIN 1000,{v}')  # Send test signal of frequency and voltage required
                afg_flag = True
        self.timerStarted.emit(False)
        self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: 'OUTP 0'."))
        self._AFG.write('OUTP 0')
        self.measurementProgress.emit(0)

    def test_linearity_ref_range(self) -> None:
        """
        Method for performing the level linearity on the reference level range test, according to the IEC 61672-3:2013
        Art. 16. For that purpose, this method starts a timer, sets sine signals of certain amplitude depending on the
        level on the linearity range, and, after about 25 seconds, finishes the timer. While timer is running,
        the video frames are acquired and stored.
        :return: None
        """
        from math import log10, ceil
        measurement_progress = 0
        measuring_time = 25  # Time for capturing video frames (including stabilization time)
        total_steps = measuring_time * 10 * self._dut.calibration_results['Linearity Reference Range'].shape[0]
        v_ref = self._dut.calibration_results['Reference Voltage']['Middle V']
        fw_corr = self._dut.calibration_results['Electrical Frequency Weightings'].loc[('A', 8000), 'LR_rel']
        ff_corr = self._dut.calibration_results['Electrical Frequency Weightings'].loc[('A', 8000), 'R']
        lin_start_lev = 20 * log10(v_ref) - (self._dut.lin_start_point -
                                             self._dut.reference_level) + 1.1 - fw_corr + ff_corr
        for i in range(self._dut.calibration_results['Linearity Reference Range'].shape[0]):
            lev = self._dut.calibration_results['Linearity Reference Range'].index[i]
            v = 10 ** (((lev - self._dut.lin_start_point) + lin_start_lev) / 20)
            gain = 0
            if v > self._AFG.info['Limits'].loc['Out 1', 'Without gain']:  # Checks if voltage requires gain or atten
                gain = 6
            elif v < self._AFG.info['Limits'].loc['Out 1', 'Without attenuation']:
                gain = -ceil((20 * log10(self._AFG.info['Limits'].loc['Out 1', 'Without attenuation']) -
                              20 * log10(v)) / 10) * 10
            self._dut.calibration_results['Linearity Reference Range'].iat[i, 1] = gain
            v = 10 ** ((20 * log10(v) - gain) / 20)  # Adjusts the voltage to the calculated gain or attenuation
            self._dut.calibration_results['Linearity Reference Range'].iat[i, 0] = v
            if gain != self._AFG.gain:  # Ask for a manual change of gain on DecadeBox and waits to continue
                self.gainChanged.emit(int(gain))
                self._AFG.gain = gain
                self.set_state(2)
                self.check_state()
            # Starts timer for video capturing
            self.timerStarted.emit(True)
            total_time = 0
            afg_flag = False
            for t in range(1, measuring_time * 10 + 1):
                self.check_state()
                sleep(1 / 10)
                total_time += t / 10
                measurement_progress += 1 / total_steps * 100
                self.measurementProgress.emit(int(measurement_progress))
                if not afg_flag and total_time >= 0.3:
                    self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: ':APPL:SIN 8000,{v}'."))
                    self._AFG.write(f':APPL:SIN 8000,{v}')  # Send test signal of frequency and voltage required
                    afg_flag = True
            self.timerStarted.emit(False)
            self._calibration_substage += 1
            sleep(1)
        self.loggingMsg.emit((0, f"Comando SCPI enviado vía GPIB: 'OUTP 0'."))
        self._AFG.write('OUTP 0')
        self.measurementProgress.emit(0)

    def set_state(self, state: int) -> None:
        if 0 <= state <= 2:
            mutex.lock()
            self._calibration_state = state
            mutex.unlock()
        else:
            raise RuntimeError('You most assign only 0: stopped, 1: running, 2: paused.')

    def read_screen(self, img: np.ndarray, stabilization: bool) -> float:
        """
        This method segments each digit with threshold Otsu, extracts a features vector based on SIFT
        descriptor, reduces the dimensionality by KPCA, and finally classify the samples
        with a Gaussian naive Bayes classifier
        :param img: The matrix representation of the image in uint8 format (OpenCV).
        :param stabilization: True or False indicating if the given frames corresponds to the stabilization time or not.
        :return: The result obtained as a float number.
        """
        descriptor = cv.SIFT_create()  # Crea un descriptor SIFT
        X = []  # Features arrays of test samples
        # Gaussian filter
        roi = cv.GaussianBlur(img.copy(), ksize=(0, 0), sigmaX=1.7)
        img_bin_full = cv.threshold(roi, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)[1]  # Otsu binarization
        # Localization of each digit
        digits_contours, _ = cv.findContours(img_bin_full, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
        x_coords = []
        digits = []
        for digit_contour in digits_contours:
            [x, y_hat, w, h] = cv.boundingRect(digit_contour)
            digit = roi[y_hat:y_hat + h, x:x + w]
            mayor_axis = max(digit.shape)  # The largest axis
            digit_scaled = cv.resize(digit, (0, 0), fx=32 / mayor_axis,  # Normalize size
                                     fy=32 / mayor_axis, interpolation=cv.INTER_CUBIC)
            # Build an frames of 32 x 32 pixels
            if digit_scaled.shape[0] >= digit_scaled.shape[1]:
                digit_scaled = np.pad(digit_scaled, ((0, 0), ((32 - digit_scaled.shape[1]) // 2,
                                                              (32 - digit_scaled.shape[1]) // 2)), 'constant')
            else:
                digit_scaled = np.pad(digit_scaled, (((32 - digit_scaled.shape[0]) // 2,
                                                      (32 - digit_scaled.shape[0]) // 2), (0, 0)), 'constant')
            img_bin = cv.threshold(digit_scaled, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)[1]  # Otsu binarization
            key_points = [cv.KeyPoint(7, 7, 16), cv.KeyPoint(7, 13, 16),
                          cv.KeyPoint(13, 7, 16), cv.KeyPoint(13, 13, 16)]
            _, des = descriptor.compute(img_bin, key_points)  # Computes SIFT descriptor
            X.append(des.flatten())  # Add the features vector of the actual sample
            x_coords.append(x)
            digits.append(img_bin)

        x_coords = np.array(x_coords)
        X = np.array(X)  # Convert test sample features vector to numpy array
        # -------- DIMENSIONALITY REDUCTION BY KERNEL PCA --------- #
        X = SLMPeriodicTester.__kpcaModel.transform(X)
        X = X[x_coords.argsort()]
        # ------- CLASSIFY ---------#
        y_hat = SLMPeriodicTester.__gnbClassifier.predict(X)
        # Convert to float
        result = ''
        for char in y_hat:
            if char == 'p':
                char = '.'
            result += char
        try:
            if float(result) > 180 and not stabilization:
                self.loggingMsg.emit((2, f'Error en reconocimiento, valor ignorado: {result} dB.'))
                self.wrong_frames.append([img_bin_full, digits])
                with open('CalibrationResults/ElectricalFrequencyWeightings/wrong_frames.pkl', 'wb') as file:
                    pickle.dump(self.wrong_frames, file)
            return float(result)
        except ValueError:
            # For debugging purposes only, here, the wrong recognized frames are stored on disk.
            if not stabilization:
                self.loggingMsg.emit((2, f'Error en reconocimiento, valor ignorado: {result} dB.'))
                self.wrong_frames.append([img_bin_full, digits])
                with open('CalibrationResults/ElectricalFrequencyWeightings/wrong_frames.pkl', 'wb') as file:
                    pickle.dump(self.wrong_frames, file)
            return np.nan

    @staticmethod
    def level2volt(lev: float, ref_lev: tuple) -> float:
        """
        This method returns the voltage value corresponding to the required level in function
        of the voltage that produces an indication of the reference level.
        :param lev: Level of which its corresponding voltage is required
        :param ref_lev: Tuple of (reference level, corresponding reference voltage)
        :return: Voltage corresponding to the required level
        """
        from math import log10
        volt_level = 20 * log10(ref_lev[1]) + (lev - ref_lev[0])
        return 10 ** (volt_level / 20)

    @property
    def DMM(self):
        return self._DMM

    @property
    def AFG(self):
        return self._AFG

    @property
    def dut(self):
        return self._dut

    @property
    def resource_manager(self):
        return self._resource_manager

    @property
    def ref_range(self):
        return self._ref_range

    @property
    def ref_level(self):
        return self._ref_lev

    @property
    def elect_frec_weight_results(self):
        return self._elect_frec_weight_results

    @property
    def stage(self):
        return self._calibration_stage

    @property
    def substage(self):
        return self._calibration_substage

    @property
    def state(self):
        return self._calibration_state

    @property
    def power_supply_results(self):
        return self._power_supply_results
